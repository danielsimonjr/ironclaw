//! Skill vulnerability scanner.
//!
//! Scans skill and tool code for potential security vulnerabilities
//! before loading. Checks for common security anti-patterns like
//! hardcoded secrets, command injection, unsafe network access, etc.

use std::collections::HashMap;
use std::time::Instant;

use regex::Regex;
use serde::{Deserialize, Serialize};

/// Severity level of a vulnerability finding.
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum Severity {
    /// Informational finding.
    Info,
    /// Low-severity issue.
    Low,
    /// Medium-severity issue.
    Medium,
    /// High-severity issue.
    High,
    /// Critical security vulnerability.
    Critical,
}

impl std::fmt::Display for Severity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Self::Info => write!(f, "info"),
            Self::Low => write!(f, "low"),
            Self::Medium => write!(f, "medium"),
            Self::High => write!(f, "high"),
            Self::Critical => write!(f, "critical"),
        }
    }
}

/// A vulnerability finding from scanning.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Finding {
    /// Rule that triggered this finding.
    pub rule_id: String,
    /// Severity level.
    pub severity: Severity,
    /// Human-readable description.
    pub description: String,
    /// The matched pattern or evidence.
    pub evidence: Option<String>,
    /// Line number where the finding was detected (if applicable).
    pub line: Option<usize>,
    /// Recommendation for fixing.
    pub recommendation: String,
}

/// Result of scanning a skill or tool.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ScanResult {
    /// Name of the scanned skill/tool.
    pub name: String,
    /// Whether the scan passed (no high/critical findings).
    pub passed: bool,
    /// All findings.
    pub findings: Vec<Finding>,
    /// Summary counts by severity.
    pub summary: HashMap<Severity, usize>,
    /// Total scan time in milliseconds.
    pub scan_time_ms: u64,
}

/// A scanning rule that checks for a specific pattern.
#[derive(Debug, Clone)]
pub struct ScanRule {
    /// Unique rule identifier.
    pub id: String,
    /// Severity if triggered.
    pub severity: Severity,
    /// Description of what this rule checks.
    pub description: String,
    /// Regex patterns to match.
    pub patterns: Vec<String>,
    /// Recommendation text.
    pub recommendation: String,
}

/// Vulnerability scanner for skills and tools.
pub struct VulnerabilityScanner {
    rules: Vec<ScanRule>,
    /// Compiled regex patterns, keyed by rule index.
    compiled: Vec<Vec<Regex>>,
    /// Minimum severity to report (default: Info).
    min_severity: Severity,
    /// Whether to fail on high/critical findings.
    fail_on_high: bool,
}

impl VulnerabilityScanner {
    /// Create a new vulnerability scanner with no rules.
    pub fn new() -> Self {
        Self {
            rules: Vec::new(),
            compiled: Vec::new(),
            min_severity: Severity::Info,
            fail_on_high: true,
        }
    }

    /// Set the minimum severity level to report.
    pub fn with_min_severity(mut self, severity: Severity) -> Self {
        self.min_severity = severity;
        self
    }

    /// Set whether to fail the scan on high/critical findings.
    pub fn with_fail_on_high(mut self, fail: bool) -> Self {
        self.fail_on_high = fail;
        self
    }

    /// Add a custom scanning rule.
    pub fn add_rule(&mut self, rule: ScanRule) {
        let compiled_patterns: Vec<Regex> = rule
            .patterns
            .iter()
            .filter_map(|p| Regex::new(p).ok())
            .collect();
        self.compiled.push(compiled_patterns);
        self.rules.push(rule);
    }

    /// Load default security rules.
    pub fn with_default_rules(mut self) -> Self {
        let rules = default_rules();
        for rule in rules {
            self.add_rule(rule);
        }
        self
    }

    /// Scan source code for vulnerabilities.
    pub fn scan(&self, name: &str, source: &str) -> ScanResult {
        let start = Instant::now();
        let mut findings = Vec::new();

        for (rule_idx, rule) in self.rules.iter().enumerate() {
            if rule.severity < self.min_severity {
                continue;
            }

            let compiled = &self.compiled[rule_idx];
            for regex in compiled {
                for line_match in source.lines().enumerate() {
                    let (line_num, line_content) = line_match;
                    if let Some(m) = regex.find(line_content) {
                        findings.push(Finding {
                            rule_id: rule.id.clone(),
                            severity: rule.severity,
                            description: rule.description.clone(),
                            evidence: Some(m.as_str().to_string()),
                            line: Some(line_num + 1),
                            recommendation: rule.recommendation.clone(),
                        });
                    }
                }
            }
        }

        let summary = build_summary(&findings);
        let has_high_or_critical = findings.iter().any(|f| f.severity >= Severity::High);
        let passed = if self.fail_on_high {
            !has_high_or_critical
        } else {
            true
        };

        ScanResult {
            name: name.to_string(),
            passed,
            findings,
            summary,
            scan_time_ms: start.elapsed().as_millis() as u64,
        }
    }

    /// Scan a capabilities.json manifest for vulnerabilities.
    pub fn scan_manifest(&self, name: &str, manifest: &serde_json::Value) -> ScanResult {
        // Use compact serialization so JSON key-value pairs remain on a single line,
        // allowing line-oriented regex patterns to match across keys and values.
        let manifest_str = serde_json::to_string(manifest).unwrap_or_default();
        self.scan(name, &manifest_str)
    }

    /// Scan both source and manifest, merging results.
    pub fn scan_full(&self, name: &str, source: &str, manifest: &serde_json::Value) -> ScanResult {
        let start = Instant::now();

        let source_result = self.scan(name, source);
        let manifest_result = self.scan_manifest(name, manifest);

        let mut findings = source_result.findings;
        findings.extend(manifest_result.findings);

        let summary = build_summary(&findings);
        let has_high_or_critical = findings.iter().any(|f| f.severity >= Severity::High);
        let passed = if self.fail_on_high {
            !has_high_or_critical
        } else {
            true
        };

        ScanResult {
            name: name.to_string(),
            passed,
            findings,
            summary,
            scan_time_ms: start.elapsed().as_millis() as u64,
        }
    }
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}

/// Build a summary of finding counts by severity.
fn build_summary(findings: &[Finding]) -> HashMap<Severity, usize> {
    let mut summary = HashMap::new();
    for finding in findings {
        *summary.entry(finding.severity).or_insert(0) += 1;
    }
    summary
}

/// Get default vulnerability scanning rules.
pub fn default_rules() -> Vec<ScanRule> {
    vec![
        // Hardcoded secrets
        ScanRule {
            id: "HARDCODED_SECRET".to_string(),
            severity: Severity::Critical,
            description: "Hardcoded API key or secret detected".to_string(),
            patterns: vec![
                r#"(?i)(api[_-]?key|secret[_-]?key|access[_-]?token|auth[_-]?token)"?\s*[=:]\s*["'][a-zA-Z0-9]{16,}"#.to_string(),
                r#"(?i)(sk-[a-zA-Z0-9]{20,})"#.to_string(),
                r#"(?i)(ghp_[a-zA-Z0-9]{36})"#.to_string(),
                r#"(?i)AKIA[0-9A-Z]{16}"#.to_string(),
            ],
            recommendation: "Use environment variables or credential injection instead of hardcoded secrets".to_string(),
        },
        // Command injection
        ScanRule {
            id: "COMMAND_INJECTION".to_string(),
            severity: Severity::High,
            description: "Potential command injection via unsanitized input".to_string(),
            patterns: vec![
                r#"(?i)(exec|system|popen|spawn|shell_exec)\s*\("#.to_string(),
                r#"(?i)subprocess\.(call|run|Popen)"#.to_string(),
                r#"(?i)child_process\.(exec|spawn)"#.to_string(),
            ],
            recommendation: "Sanitize all user input before passing to shell commands".to_string(),
        },
        // Unsafe eval
        ScanRule {
            id: "UNSAFE_EVAL".to_string(),
            severity: Severity::High,
            description: "Use of eval() or equivalent dynamic code execution".to_string(),
            patterns: vec![
                r#"\beval\s*\("#.to_string(),
                r#"\bFunction\s*\("#.to_string(),
                r#"(?i)compile\s*\(.*exec"#.to_string(),
            ],
            recommendation: "Avoid eval() and dynamic code execution; use structured data instead".to_string(),
        },
        // Unsafe network access
        ScanRule {
            id: "UNRESTRICTED_NETWORK".to_string(),
            severity: Severity::Medium,
            description: "Unrestricted network access to external endpoints".to_string(),
            patterns: vec![
                r#"(?i)(fetch|request|http\.get|axios|urllib)\s*\(\s*[^"']*\+"#.to_string(),
            ],
            recommendation: "Use URL allowlists and validate all external URLs".to_string(),
        },
        // File system access
        ScanRule {
            id: "FILESYSTEM_ACCESS".to_string(),
            severity: Severity::Medium,
            description: "Direct filesystem access detected".to_string(),
            patterns: vec![
                r#"(?i)(readFile|writeFile|appendFile|unlink|rmdir|mkdir)\s*\("#.to_string(),
                r#"(?i)open\s*\([^)]*,\s*["']w"#.to_string(),
                r#"(?i)std::fs::(write|remove|create_dir)"#.to_string(),
            ],
            recommendation: "Use sandboxed file operations through the tool API".to_string(),
        },
        // SQL injection
        ScanRule {
            id: "SQL_INJECTION".to_string(),
            severity: Severity::High,
            description: "Potential SQL injection via string concatenation".to_string(),
            patterns: vec![
                r#"(?i)(SELECT|INSERT|UPDATE|DELETE|DROP)\s+.*\+\s*[a-zA-Z]"#.to_string(),
                r#"(?i)format!\s*\(\s*"[^"]*(?:SELECT|INSERT|UPDATE|DELETE)"#.to_string(),
            ],
            recommendation: "Use parameterized queries instead of string concatenation".to_string(),
        },
        // Sensitive data logging
        ScanRule {
            id: "SENSITIVE_LOGGING".to_string(),
            severity: Severity::Medium,
            description: "Potentially logging sensitive data".to_string(),
            patterns: vec![
                r#"(?i)(console\.log|print|println|tracing::\w+!)\s*\([^)]*(?:password|secret|token|key|credential)"#.to_string(),
            ],
            recommendation: "Redact sensitive data before logging".to_string(),
        },
        // Insecure crypto
        ScanRule {
            id: "WEAK_CRYPTO".to_string(),
            severity: Severity::Medium,
            description: "Use of weak or deprecated cryptographic algorithms".to_string(),
            patterns: vec![
                r#"(?i)(md5|sha1)\s*[\.(]"#.to_string(),
                r#"(?i)DES|RC4|Blowfish"#.to_string(),
            ],
            recommendation: "Use modern cryptographic algorithms (SHA-256+, AES-256-GCM)".to_string(),
        },
        // Path traversal
        ScanRule {
            id: "PATH_TRAVERSAL".to_string(),
            severity: Severity::High,
            description: "Potential path traversal vulnerability".to_string(),
            patterns: vec![
                r#"\.\./\.\."#.to_string(),
                r#"(?i)(path\.join|resolve)\s*\([^)]*\+"#.to_string(),
            ],
            recommendation: "Validate and canonicalize all file paths".to_string(),
        },
        // Excessive permissions
        ScanRule {
            id: "EXCESSIVE_PERMISSIONS".to_string(),
            severity: Severity::Low,
            description: "Requesting more permissions than likely needed".to_string(),
            patterns: vec![
                r#"(?i)"permissions"\s*:\s*\[\s*"\*""#.to_string(),
                r#"(?i)chmod\s+777"#.to_string(),
            ],
            recommendation: "Request minimal permissions following principle of least privilege".to_string(),
        },
    ]
}

#[cfg(test)]
mod tests {
    use super::*;

    fn scanner() -> VulnerabilityScanner {
        VulnerabilityScanner::new().with_default_rules()
    }

    // --- Default rules loading ---

    #[test]
    fn test_default_rules_loaded() {
        let rules = default_rules();
        assert!(rules.len() >= 10, "Expected at least 10 default rules");
    }

    #[test]
    fn test_scanner_with_default_rules() {
        let s = scanner();
        assert!(!s.rules.is_empty());
        assert_eq!(s.rules.len(), s.compiled.len());
    }

    #[test]
    fn test_all_default_rule_patterns_compile() {
        let rules = default_rules();
        for rule in &rules {
            for pattern in &rule.patterns {
                assert!(
                    Regex::new(pattern).is_ok(),
                    "Pattern '{}' in rule '{}' failed to compile",
                    pattern,
                    rule.id
                );
            }
        }
    }

    // --- Clean code (no findings) ---

    #[test]
    fn test_scan_clean_code_no_findings() {
        let s = scanner();
        let source = r#"
            fn hello() {
                let greeting = "Hello, world!";
                println!("{}", greeting);
            }
        "#;
        let result = s.scan("clean_tool", source);
        assert!(result.passed);
        assert!(result.findings.is_empty());
        assert_eq!(result.name, "clean_tool");
    }

    #[test]
    fn test_scan_clean_code_summary_empty() {
        let s = scanner();
        let result = s.scan("clean", "fn main() {}");
        assert!(result.summary.is_empty());
    }

    // --- Detecting hardcoded API keys ---

    #[test]
    fn test_detect_hardcoded_api_key() {
        let s = scanner();
        let source = r#"let api_key = "abcdefghijklmnop1234567890";"#;
        let result = s.scan("test_tool", source);
        assert!(!result.passed);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "HARDCODED_SECRET")
        );
    }

    #[test]
    fn test_detect_openai_sk_key() {
        let s = scanner();
        let source = r#"let key = "sk-abc123def456ghi789jkl012mno";"#;
        let result = s.scan("test_tool", source);
        assert!(!result.passed);
        let secret_findings: Vec<_> = result
            .findings
            .iter()
            .filter(|f| f.rule_id == "HARDCODED_SECRET")
            .collect();
        assert!(!secret_findings.is_empty());
    }

    #[test]
    fn test_detect_github_token() {
        let s = scanner();
        let source = r#"const TOKEN = "ghp_ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghij";"#;
        let result = s.scan("test_tool", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "HARDCODED_SECRET")
        );
    }

    #[test]
    fn test_detect_aws_access_key() {
        let s = scanner();
        let source = r#"aws_key = "AKIAIOSFODNN7EXAMPLE""#;
        let result = s.scan("test_tool", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "HARDCODED_SECRET")
        );
    }

    // --- Detecting command injection ---

    #[test]
    fn test_detect_command_injection_exec() {
        let s = scanner();
        let source = r#"exec("rm -rf /")"#;
        let result = s.scan("test_tool", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "COMMAND_INJECTION")
        );
    }

    #[test]
    fn test_detect_command_injection_system() {
        let s = scanner();
        let source = r#"system("ls -la")"#;
        let result = s.scan("test_tool", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "COMMAND_INJECTION")
        );
    }

    #[test]
    fn test_detect_subprocess_call() {
        let s = scanner();
        let source = r#"subprocess.call(["ls", "-la"])"#;
        let result = s.scan("test_tool", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "COMMAND_INJECTION")
        );
    }

    #[test]
    fn test_detect_child_process_exec() {
        let s = scanner();
        let source = r#"child_process.exec("node script.js")"#;
        let result = s.scan("test_tool", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "COMMAND_INJECTION")
        );
    }

    // --- Detecting eval usage ---

    #[test]
    fn test_detect_eval() {
        let s = scanner();
        let source = r#"eval("alert(1)")"#;
        let result = s.scan("test_tool", source);
        assert!(result.findings.iter().any(|f| f.rule_id == "UNSAFE_EVAL"));
    }

    #[test]
    fn test_detect_function_constructor() {
        let s = scanner();
        let source = r#"new Function("return 1")"#;
        let result = s.scan("test_tool", source);
        assert!(result.findings.iter().any(|f| f.rule_id == "UNSAFE_EVAL"));
    }

    // --- Detecting SQL injection ---

    #[test]
    fn test_detect_sql_injection_concatenation() {
        let s = scanner();
        let source = r#"query = "SELECT * FROM users WHERE name = '" + user_input"#;
        let result = s.scan("test_tool", source);
        assert!(result.findings.iter().any(|f| f.rule_id == "SQL_INJECTION"));
    }

    #[test]
    fn test_detect_sql_injection_format_macro() {
        let s = scanner();
        let source = r#"let q = format!("SELECT * FROM users WHERE id = {}", id);"#;
        let result = s.scan("test_tool", source);
        assert!(result.findings.iter().any(|f| f.rule_id == "SQL_INJECTION"));
    }

    // --- Detecting path traversal ---

    #[test]
    fn test_detect_path_traversal() {
        let s = scanner();
        let source = r#"let p = "../../etc/passwd";"#;
        let result = s.scan("test_tool", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "PATH_TRAVERSAL")
        );
    }

    #[test]
    fn test_detect_path_join_concatenation() {
        let s = scanner();
        let source = r#"let full = path.join(base + user_dir)"#;
        let result = s.scan("test_tool", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "PATH_TRAVERSAL")
        );
    }

    // --- Detecting weak crypto ---

    #[test]
    fn test_detect_weak_crypto_md5() {
        let s = scanner();
        let source = r#"let hash = md5.digest("data");"#;
        let result = s.scan("test_tool", source);
        assert!(result.findings.iter().any(|f| f.rule_id == "WEAK_CRYPTO"));
    }

    #[test]
    fn test_detect_weak_crypto_sha1() {
        let s = scanner();
        let source = r#"let h = sha1.update("data");"#;
        let result = s.scan("test_tool", source);
        assert!(result.findings.iter().any(|f| f.rule_id == "WEAK_CRYPTO"));
    }

    #[test]
    fn test_detect_weak_crypto_des() {
        let s = scanner();
        let source = r#"let cipher = DES.new(key);"#;
        let result = s.scan("test_tool", source);
        assert!(result.findings.iter().any(|f| f.rule_id == "WEAK_CRYPTO"));
    }

    // --- Severity ordering ---

    #[test]
    fn test_severity_ordering() {
        assert!(Severity::Info < Severity::Low);
        assert!(Severity::Low < Severity::Medium);
        assert!(Severity::Medium < Severity::High);
        assert!(Severity::High < Severity::Critical);
    }

    #[test]
    fn test_severity_display() {
        assert_eq!(Severity::Info.to_string(), "info");
        assert_eq!(Severity::Low.to_string(), "low");
        assert_eq!(Severity::Medium.to_string(), "medium");
        assert_eq!(Severity::High.to_string(), "high");
        assert_eq!(Severity::Critical.to_string(), "critical");
    }

    #[test]
    fn test_severity_equality() {
        assert_eq!(Severity::High, Severity::High);
        assert_ne!(Severity::High, Severity::Low);
    }

    // --- Min severity filtering ---

    #[test]
    fn test_min_severity_filters_low() {
        let s = VulnerabilityScanner::new()
            .with_default_rules()
            .with_min_severity(Severity::High);

        // chmod 777 triggers EXCESSIVE_PERMISSIONS (Low severity)
        // This should be filtered out since min severity is High
        let source = r#"chmod 777 /tmp/dir"#;
        let result = s.scan("test_tool", source);
        assert!(
            !result
                .findings
                .iter()
                .any(|f| f.rule_id == "EXCESSIVE_PERMISSIONS"),
            "Low-severity findings should be filtered when min_severity is High"
        );
    }

    #[test]
    fn test_min_severity_keeps_high() {
        let s = VulnerabilityScanner::new()
            .with_default_rules()
            .with_min_severity(Severity::High);

        let source = r#"eval("dangerous code")"#;
        let result = s.scan("test_tool", source);
        assert!(
            result.findings.iter().any(|f| f.rule_id == "UNSAFE_EVAL"),
            "High-severity findings should be kept when min_severity is High"
        );
    }

    // --- Scan result summary counts ---

    #[test]
    fn test_scan_result_summary_counts() {
        let s = scanner();
        // Combine sources with multiple severity levels
        let source = r#"
            let api_key = "abcdefghijklmnop1234567890";
            eval("danger");
            chmod 777 /tmp;
            md5.digest("data");
        "#;
        let result = s.scan("multi", source);
        assert!(!result.summary.is_empty());

        // Critical: hardcoded secret
        assert!(result.summary.get(&Severity::Critical).unwrap_or(&0) > &0);
        // High: eval
        assert!(result.summary.get(&Severity::High).unwrap_or(&0) > &0);
    }

    // --- Pass/fail determination ---

    #[test]
    fn test_scan_fails_on_critical() {
        let s = scanner();
        let source = r#"let api_key = "abcdefghijklmnop1234567890";"#;
        let result = s.scan("test", source);
        assert!(!result.passed);
    }

    #[test]
    fn test_scan_fails_on_high() {
        let s = scanner();
        let source = r#"eval("code")"#;
        let result = s.scan("test", source);
        assert!(!result.passed);
    }

    #[test]
    fn test_scan_passes_with_only_medium() {
        let s = VulnerabilityScanner::new().with_fail_on_high(true);
        let rule = ScanRule {
            id: "TEST_MEDIUM".to_string(),
            severity: Severity::Medium,
            description: "Medium test".to_string(),
            patterns: vec![r#"medium_trigger"#.to_string()],
            recommendation: "Fix it".to_string(),
        };
        let mut scanner = s;
        scanner.add_rule(rule);

        let result = scanner.scan("test", "medium_trigger here");
        assert!(
            result.passed,
            "Should pass with only medium findings when fail_on_high is true"
        );
    }

    #[test]
    fn test_scan_passes_when_fail_on_high_disabled() {
        let s = VulnerabilityScanner::new()
            .with_default_rules()
            .with_fail_on_high(false);

        let source = r#"eval("danger")"#;
        let result = s.scan("test", source);
        assert!(
            result.passed,
            "Should pass even with high findings when fail_on_high is false"
        );
    }

    // --- Multiple findings in one scan ---

    #[test]
    fn test_multiple_findings() {
        let s = scanner();
        let source = r#"
            let api_key = "abcdefghijklmnop1234567890";
            eval("code");
            system("ls");
            let p = "../../etc/shadow";
        "#;
        let result = s.scan("multi", source);
        assert!(result.findings.len() >= 4, "Expected at least 4 findings");
        assert!(!result.passed);
    }

    #[test]
    fn test_finding_has_line_number() {
        let s = scanner();
        let source = "line 1\neval(\"code\")\nline 3";
        let result = s.scan("test", source);
        let eval_finding = result.findings.iter().find(|f| f.rule_id == "UNSAFE_EVAL");
        assert!(eval_finding.is_some());
        assert_eq!(eval_finding.unwrap().line, Some(2));
    }

    #[test]
    fn test_finding_has_evidence() {
        let s = scanner();
        let source = r#"eval("code")"#;
        let result = s.scan("test", source);
        let finding = result
            .findings
            .iter()
            .find(|f| f.rule_id == "UNSAFE_EVAL")
            .unwrap();
        assert!(finding.evidence.is_some());
        assert!(finding.evidence.as_ref().unwrap().contains("eval"));
    }

    // --- Manifest scanning ---

    #[test]
    fn test_scan_manifest_clean() {
        let s = scanner();
        let manifest = serde_json::json!({
            "name": "safe_tool",
            "version": "1.0.0",
            "permissions": ["read"]
        });
        let result = s.scan_manifest("safe_tool", &manifest);
        assert!(result.passed);
        assert!(result.findings.is_empty());
    }

    #[test]
    fn test_scan_manifest_excessive_permissions() {
        let s = scanner();
        let manifest = serde_json::json!({
            "name": "greedy_tool",
            "permissions": ["*"]
        });
        let result = s.scan_manifest("greedy_tool", &manifest);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "EXCESSIVE_PERMISSIONS")
        );
    }

    #[test]
    fn test_scan_manifest_with_hardcoded_secret() {
        let s = scanner();
        let manifest = serde_json::json!({
            "name": "leaky_tool",
            "config": {
                "api_key": "abcdefghijklmnop1234567890abcd"
            }
        });
        let result = s.scan_manifest("leaky_tool", &manifest);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "HARDCODED_SECRET")
        );
    }

    // --- Full scan (source + manifest) ---

    #[test]
    fn test_scan_full_merges_findings() {
        let s = scanner();
        let source = r#"eval("code")"#;
        let manifest = serde_json::json!({
            "permissions": ["*"]
        });
        let result = s.scan_full("combined", source, &manifest);
        assert!(result.findings.iter().any(|f| f.rule_id == "UNSAFE_EVAL"));
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "EXCESSIVE_PERMISSIONS")
        );
        assert_eq!(result.name, "combined");
    }

    #[test]
    fn test_scan_full_clean() {
        let s = scanner();
        let source = "fn safe() {}";
        let manifest = serde_json::json!({"name": "safe"});
        let result = s.scan_full("safe", source, &manifest);
        assert!(result.passed);
        assert!(result.findings.is_empty());
    }

    // --- Custom rule addition ---

    #[test]
    fn test_custom_rule_addition() {
        let mut s = VulnerabilityScanner::new();
        s.add_rule(ScanRule {
            id: "CUSTOM_CHECK".to_string(),
            severity: Severity::Info,
            description: "Custom check for TODO comments".to_string(),
            patterns: vec![r#"TODO"#.to_string()],
            recommendation: "Resolve TODO items before deployment".to_string(),
        });

        let result = s.scan("test", "// TODO: fix this later");
        assert!(result.findings.iter().any(|f| f.rule_id == "CUSTOM_CHECK"));
    }

    #[test]
    fn test_custom_rule_does_not_interfere_with_defaults() {
        let mut s = VulnerabilityScanner::new().with_default_rules();
        let initial_count = s.rules.len();

        s.add_rule(ScanRule {
            id: "CUSTOM_EXTRA".to_string(),
            severity: Severity::Info,
            description: "Extra custom rule".to_string(),
            patterns: vec![r#"FIXME"#.to_string()],
            recommendation: "Fix it".to_string(),
        });

        assert_eq!(s.rules.len(), initial_count + 1);
    }

    // --- Empty source handling ---

    #[test]
    fn test_scan_empty_source() {
        let s = scanner();
        let result = s.scan("empty", "");
        assert!(result.passed);
        assert!(result.findings.is_empty());
        assert!(result.summary.is_empty());
    }

    #[test]
    fn test_scan_whitespace_only_source() {
        let s = scanner();
        let result = s.scan("whitespace", "   \n\n\t  \n  ");
        assert!(result.passed);
        assert!(result.findings.is_empty());
    }

    // --- Rule pattern matching edge cases ---

    #[test]
    fn test_case_insensitive_matching() {
        let s = scanner();
        let source = r#"API_KEY = "abcdefghijklmnop1234567890""#;
        let result = s.scan("test", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "HARDCODED_SECRET")
        );
    }

    #[test]
    fn test_partial_match_not_triggered() {
        let s = scanner();
        // "evaluate" should NOT trigger the eval rule because the pattern requires \beval\s*\(
        let source = r#"let result = evaluate_expression();"#;
        let result = s.scan("test", source);
        assert!(
            !result.findings.iter().any(|f| f.rule_id == "UNSAFE_EVAL"),
            "The word 'evaluate' should not trigger UNSAFE_EVAL"
        );
    }

    #[test]
    fn test_no_false_positive_on_safe_hash_reference() {
        let s = scanner();
        // Referencing SHA-256 (safe) should not trigger weak crypto
        let source = r#"let hasher = sha256::digest("data");"#;
        let result = s.scan("test", source);
        assert!(
            !result.findings.iter().any(|f| f.rule_id == "WEAK_CRYPTO"),
            "SHA-256 should not trigger WEAK_CRYPTO"
        );
    }

    #[test]
    fn test_scan_result_has_scan_time() {
        let s = scanner();
        let result = s.scan("test", "fn main() {}");
        // scan_time_ms should be set (it could be 0 for very fast scans, but it's set)
        assert!(result.scan_time_ms < 10_000, "Scan should complete quickly");
    }

    // --- Filesystem access detection ---

    #[test]
    fn test_detect_filesystem_write() {
        let s = scanner();
        let source = r#"std::fs::write("output.txt", data);"#;
        let result = s.scan("test", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "FILESYSTEM_ACCESS")
        );
    }

    #[test]
    fn test_detect_filesystem_node_writefile() {
        let s = scanner();
        let source = r#"writeFile("test.txt", content, callback)"#;
        let result = s.scan("test", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "FILESYSTEM_ACCESS")
        );
    }

    // --- Serialization ---

    #[test]
    fn test_severity_serde_roundtrip() {
        let severity = Severity::Critical;
        let json = serde_json::to_string(&severity).unwrap();
        assert_eq!(json, r#""critical""#);
        let deserialized: Severity = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized, severity);
    }

    #[test]
    fn test_finding_serde_roundtrip() {
        let finding = Finding {
            rule_id: "TEST".to_string(),
            severity: Severity::High,
            description: "Test finding".to_string(),
            evidence: Some("evidence".to_string()),
            line: Some(42),
            recommendation: "Fix it".to_string(),
        };
        let json = serde_json::to_string(&finding).unwrap();
        let deserialized: Finding = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.rule_id, "TEST");
        assert_eq!(deserialized.severity, Severity::High);
        assert_eq!(deserialized.line, Some(42));
    }

    #[test]
    fn test_scan_result_serde_roundtrip() {
        let s = scanner();
        let result = s.scan("serde_test", r#"eval("x")"#);
        let json = serde_json::to_string(&result).unwrap();
        let deserialized: ScanResult = serde_json::from_str(&json).unwrap();
        assert_eq!(deserialized.name, "serde_test");
        assert!(!deserialized.passed);
        assert!(!deserialized.findings.is_empty());
    }

    // --- Default trait ---

    #[test]
    fn test_scanner_default() {
        let s = VulnerabilityScanner::default();
        assert!(s.rules.is_empty());
        assert!(s.compiled.is_empty());
    }

    // --- Sensitive logging detection ---

    #[test]
    fn test_detect_sensitive_logging() {
        let s = scanner();
        let source = r#"console.log("user password is: " + password)"#;
        let result = s.scan("test", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "SENSITIVE_LOGGING")
        );
    }

    // --- Excessive permissions detection ---

    #[test]
    fn test_detect_chmod_777() {
        let s = scanner();
        let source = r#"chmod 777 /var/www"#;
        let result = s.scan("test", source);
        assert!(
            result
                .findings
                .iter()
                .any(|f| f.rule_id == "EXCESSIVE_PERMISSIONS")
        );
    }
}
